# 6 Советов по Работе с Памятью в Приложениях .NET

Проблемы с памятью в большом .NET-приложении - своего рода тихий убийца. Как гипертония. Вы можете долго есть нездоровую пищу, игнорируя её, пока однажды не столкнетесь с серьезной проблемой. В случае программы .NET серьезной проблемой может быть высокое потребление памяти, проблемы с производительностью и сбои в работе.

Как узнать, правильно ли вы используете память? Что нужно делать, чтобы с ней не возникало проблем? Мы рассмотрим 6 рекомендаций, которые помогут сохранить память в рабочем состоянии и выявить проблемы, если они возникнут.

## Объекты должны собираться сборщиком мусора как можно раньше

Чтобы ваша программа работала быстро, главная цель - как можно раньше уничтожать объекты. Чтобы понять, почему это важно, нужно иметь понятие о поколениях объектов в .NET. https://t.me/NetDeveloperDiary/208 Когда объекты создаются с помощью new, они помещаются в куче в поколении 0. Это очень маленький объем памяти. Если после сборки мусора на них по-прежнему есть ссылки, они переводятся в поколение 1. Поколение 1 - это больший объем памяти. Если после следующей сборки мусора на них по-прежнему ссылаются, они переводятся в поколение 2.

Сборки мусора в поколении 0 производятся наиболее часто и очень быстро. Сборка в поколении 1 охватывает как пространства памяти как поколения 0, так и поколения 1, поэтому она более дорогая. Сборка в поколении 2 включает в себя всё пространство памяти, включая кучу больших объектов (LOH). Сборка мусора в поколении 2 очень дорогая. Сборщик мусора (GC) оптимизирован, чтобы проводить много сборок в поколении 0, меньше в поколении 1 и очень мало сборок в поколении 2. Но, если у вас много объектов, которые переходят в более высокое поколение, вы получите обратный эффект. Это приводит к нехватке памяти (также известной как давление на GC) и снижению производительности.

Кстати, размещение новых объектов обходится крайне дешево. Единственное, о чем нужно беспокоиться, - это сборка мусора.

Так как же держать объекты в младшем поколении? Просто убедитесь, что ссылки на них удаляются как можно раньше. Некоторые объекты, например одиночки, должны всегда оставаться в памяти. Ничего страшного, обычно это будут службы, которые в любом случае не потребляют много памяти.

## Используйте кэширование… но осторожно

Такие механизмы, как кэширование, по определению проблемные. Это долговечные временные объекты, которые, скорее всего, будут переведены в поколение 2, хотя это плохо для сборщика мусора, но обычно стоит того, потому что кэширование действительно может улучшить производительность. Однако нужно следить за ним.

Один из способов уменьшить это давление на память - использовать изменяемые объекты кэша. Это означает, что вместо замены объекта кэша вы обновляете существующий объект. То есть у сборщика мусора будет меньше работы по продвижению объектов между поколениями и больше сборок мусора в поколениях 0 и 1.

Допустим, вы кэшируете товары интернет-магазина. У вас есть механизм кэширования, который хранит цены и информацию для фиксированного набора часто запрашиваемых товаров. Предположим, каждые 5 минут вы должны обновлять кэш из базы в случае изменения данных. Тогда вместо создания нового набора товаров просто изменяйте состояние существующих объектов.

## Следите за процентом времени, затрачиваемым на сборку мусора

Если вы хотите узнать, насколько сборка мусора влияет на время выполнения программы, это довольно легко сделать. Просто посмотрите на счётчик производительности (Performance Monitor) .NET CLR Memory | % Time in GC. Он покажет, какой процент времени выполнения используется сборщиком мусора. Есть много инструментов для просмотра счетчиков производительности. В Windows вы можете использовать PerfMon. В Linux вы можете использовать dotnet-trace.

Далее приведены пара «магических чисел», но относитесь к ним с подозрением, потому что у каждого приложения свой контекст. Для большого приложения 10% времени в GC – это, скорее всего, нормальный процент. 20% времени в сборке мусора - это предел, а большее число означает, что у вас проблемы.

## Следите за сборками мусора в поколении 2

Помимо процента времени на сборку мусора, другой полезной метрикой является количество сборок мусора в поколении 2. А точнее относительное количество сборок мусора в поколении 2. Задача состоит в том, чтобы их было как можно меньше. Учтите, что это полные сборки мусора во всей куче памяти. Они фактически замораживают все потоки приложения, пока сборщик мусора всё собирает.

Нельзя точно сказать, сколько сборок в поколении 2 у вас должно быть. Просто следите за их количеством, и, если этот показатель возрастает, вероятно, вы добавили какое-то нехорошее поведение. Вы можете посмотреть это число с помощью счётчика производительности .NET CLR Memory

## Следите за стабильностью потребления памяти

Рассмотрим обычное состояние приложения. Некоторые события происходят постоянно. Это может быть сервер, обслуживающий запросы, служба, извлекающая сообщения из очереди, настольное приложение с множеством форм. В это время ваше приложение постоянно создаёт новые объекты, выполняет какие-то операции, а затем освобождает эти объекты и возвращается в нормальное состояние. Это означает, что потребление памяти должно быть более или менее одинаковым в долгосрочной перспективе. Конечно, оно может возрастать во время пиковых нагрузок или интенсивной обработки данных, но после этого оно должно возвращаться в нормальное состояние.

Но если у вас есть опыт подобного отслеживания приложений, вы, вероятно, знаете, что иногда объём потребляемой памяти со временем увеличивается. Среднее потребление медленно растёт, хотя по логике этого не должно быть. Причина такого поведения почти всегда - утечки памяти. Это происходит, когда объект больше не используется, но по какой-то причине на него всё ещё ссылаются и, следовательно, он никогда не попадает в сборку мусора.

Если операция вызывает утечку объектов, каждая такая операция увеличивает потребление памяти. Когда проходит достаточно времени, потребление памяти приближается к своему пределу. В 32-битном процессе этот предел составляет 4 ГБ. В 64-битном процессе это зависит от ограничений компьютера. Когда потребление памяти приближаемся к пределу, сборщик мусора паникует. Он начинает запускать полную сборку мусора при каждом выделении памяти, чтобы не исчерпать её совсем. Это может замедлить ваше приложение до скорости улитки. Однако в итоге потребление памяти таки достигает предела, и приложение аварийно завершает работу, выбрасывая OutOfMemoryException.

Чтобы убедиться, что с вашим приложением такого не случится, активно отслеживайте потребление памяти с течением времени. Лучший способ сделать это - посмотреть на счетчик производительности Process | Private Bytes. Вы можете легко сделать это с помощью Process Explorer (https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) или PerfMon.

## Периодически ищите утечки памяти

Виновник проблем с памятью №1, без сомнения, - утечки памяти. Их легко вызвать, их можно долго игнорировать, но в итоге они наносят непоправимый ущерб. Устранять утечки памяти на этапе, когда ваше приложение систематически падает, очень сложно. Вам придётся в спешке менять код, что может приводить к разнообразным ошибкам. Поэтому очень важно вовремя вносить коррективы и избегать утечек памяти.

Нереально ожидать, что ваша команда никогда не их допустит утечек памяти. И нецелесообразно проверять их во всем приложении при каждом изменении. Вместо этого введите практику периодической проверки на утечки памяти. Это может быть еженедельно, ежемесячно или ежеквартально, как вам удобно.

Другой вариант проверять утечки памяти каждый раз, когда вы замечаете увеличение объема потребляемой памяти (как описано в совете №5). Но проблема в том, что даже небольшие утечки могут вызывать множество проблем. Например, у вас могут быть объекты, которые должны были быть собраны GC, но остаются живыми и в них продолжает исполняться какой-то код, что приводит к неправильному поведению.

Лучший способ обнаружить и исправить утечки памяти - использовать профилировщик памяти (https://t.me/NetDeveloperDiary/470).
